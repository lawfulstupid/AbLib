module AbLib.Util.Utilities where

import System.Random (randomRIO)
import System.CPUTime (getCPUTime)
import Control.DeepSeq (NFData, deepseq)
import Data.Array.IO
import Control.Monad (forM)
import Data.List (intercalate)

-- zipWith, utilising defaults
zipDef :: (a -> b -> c) -> (a,b) -> [a] -> [b] -> [c]
zipDef _ (_,_) [] [] = []
zipDef f (a,b) (x:xs) [] = f x b : zipDef f (a,b) xs []
zipDef f (a,b) [] (y:ys) = f a y : zipDef f (a,b) [] ys
zipDef f (a,b) (x:xs) (y:ys) = f x y : zipDef f (a,b) xs ys

-- delimit a list
delim :: Eq a => [a] -> [a] -> [[a]]
delim _ [] = [[]]
delim d (x:xs) = let
   h:t = delim d xs
   in if any (x==) d
      then [] : (h : t)
      else (x : h) : t
                 
eval2 :: (a -> b, a -> c) -> a -> (b, c)
eval2 (f,g) x = (f x, g x)

eval3 :: (a -> b, a -> c, a -> d) -> a -> (b, c, d)
eval3 (f,g,h) x = (f x, g x, h x)

both :: (a -> b) -> (a, a) -> (b, b)
both f (x,y) = (f x, f y)
   
count :: (a -> Bool) -> [a] -> Int
count f l = length $ filter f l

fdf :: Eq a => [a] -> [(a, Int)]
fdf [] = []
fdf (x:xs) = (x, 1 + count (== x) xs) : fdf (filter (/= x) xs)

mean :: (Real a, Fractional b) => [a] -> b
mean ns = (toFrac $ sum ns) / (toFrac $ length ns)

toFrac :: (Real a, Fractional b) => a -> b
toFrac = fromRational . toRational

shuffle :: [a] -> IO [a]
shuffle xs = sample (length xs) xs

sample :: Int -> [a] -> IO [a]
sample k xs = do
   ar <- newArray n xs
   forM [1..k] $ \i -> do
      j <- randomRIO (i,n)
      vi <- readArray ar i
      vj <- readArray ar j
      writeArray ar j vi
      return vj
   where
      n = length xs
      newArray :: Int -> [a] -> IO (IOArray Int a)
      newArray n xs = newListArray (1,n) xs

-- result is in millionths of a second
benchmark :: NFData a => a -> IO Integer
benchmark input = do
   start <- getCPUTime
   end <- deepseq input getCPUTime
   return $ div (end - start) 1000000

-- returns the possible partitions of xs into n sublist
-- maintains the order of xs
-- e iff sublists may be empty
part :: Int -> [a] -> [[[a]]]
part 1 xs = [[xs]]
part n [] = [take n $ repeat []]
part n xs = foldr1 (++) $ map aux [0 .. length xs]
   where
--   aux :: Int -> [[[a]]] -- not sure of this
   aux k = map (take k xs :) $ part (n-1) (drop k xs)

-- returns the partions generated by part that don't include nonempty elements
partn :: Int -> [a] -> [[[a]]]
partn n xs = filter (not.null.sequence) $ part n xs

printLn :: Show a => [[a]] -> IO ()
printLn xs = putStrLn $ intercalate "\n" $ map (intercalate " " . map show) xs

